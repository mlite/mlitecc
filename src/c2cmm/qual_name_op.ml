(* 
   MLite C Compiler -- Ning Wang <email@ningwang.org> 2006-2010
   
   The name `Mlite C Compiler' belongs to us, but the code is available free for
   any use in any field of endeavor.  You may redistribute Mlite C Compiler in
   whole or in part.  We ask that, as a matter of courtesy, you acknowledge its
   source and include this LICENSE file.  You may modify Mlite C Compiler and
   create derived works, with which you may do as you like, but the result may
   not be called Mlite C Compiler without written consent.
   
   The software is placed in the public domain.  It is not protected by copyright,
   and it is not protected by a ``copyleft'' agreement like the one used by the
   Free Software Foundation.
*)

open Qual_name


let copy_alloc_qname qn sname i : t = 
  let qn_class = 
    match qn.qn_class with
      | QN_PARAM_NAME s -> QN_PARAM_NAME i
      | _ -> assert false;
  in
  {
    qn_namespace = qn.qn_namespace;
    qn_span = qn.qn_span;
    qn_class = qn_class;
    qn_scopes = qn.qn_scopes;
    qn_init = qn.qn_init;
    qn_sname = sname;
  }

let stacknize_param_qname qn =
  match qn.qn_class with
    | QN_PARAM_NAME s -> ()
	(*qn.qn_class <- QN_DATA_ADDR*)
    | _ -> assert false
    
let alloc_type_name (scopes:qn_scope list) (name:string) : t =
  {
    qn_namespace = QN_DEFAULT;
    qn_span = QN_AUTO;
    qn_class = QN_TYPE_NAME;
    qn_scopes = scopes;
    qn_init = QN_NULL;
    qn_sname = name;
  }
   
let alloc_cstd_code_addr (scopes:qn_scope list) (name:string) : t =
  {
    qn_namespace = QN_CSTD;
    qn_span = QN_AUTO;
    qn_class = QN_CODE_ADDR;
    qn_scopes = scopes;
    qn_init = QN_NULL;
    qn_sname = name;
  }
 
let alloc_code_addr (scopes:qn_scope list) (name:string) : t =
  {
    qn_namespace = QN_DEFAULT;
    qn_span = QN_AUTO;
    qn_class = QN_CODE_ADDR;
    qn_scopes = scopes;
    qn_init = QN_NULL;
    qn_sname = name;
  }

let alloc_static_code_addr (scopes:qn_scope list) (name:string) :t =
  {
    qn_namespace = QN_DEFAULT;
    qn_span = QN_STATIC;
    qn_class = QN_CODE_ADDR;
    qn_scopes = scopes;
    qn_init = QN_NULL;
    qn_sname = name;
  }
      
      
let alloc_data_addr (scopes:qn_scope list) (name:string) :t =
  {
    qn_namespace = QN_DEFAULT;
    qn_span = QN_AUTO;
    qn_class = QN_DATA_ADDR;
    qn_scopes = scopes;
    qn_init = QN_NULL;
    qn_sname = name;
  }

let alloc_data_regi (scopes:qn_scope list) (name:string) :t =
  {
    qn_namespace = QN_DEFAULT;
    qn_span = QN_AUTO;
    qn_class = QN_DATA_REGI;
    qn_scopes = scopes;
    qn_init = QN_NULL;
    qn_sname = name;
  }

(*
let alloc_extern_data_addr (scopes:qn_scope list) (name:string) :t =
  {
    qn_namespace = QN_DEFAULT;
    qn_span = QN_EXTERN;
    qn_class = QN_DATA_ADDR;
    qn_scopes = scopes;
    qn_init = QN_NULL;
    qn_sname = name;
  }
*)


let alloc_static_data_addr (scopes:qn_scope list) (name:string): t =
  {
    qn_namespace = QN_DEFAULT;
    qn_span = QN_STATIC;
    qn_class = QN_DATA_ADDR;
    qn_scopes = scopes;
    qn_init = QN_NULL;
    qn_sname = name;
  }


let alloc_strn_cnst (scopes:qn_scope list) (name:string): t =
  {
    qn_namespace = QN_DEFAULT;
    qn_span = QN_STATIC;
    qn_class = QN_STRN_CNST;
    qn_scopes = scopes;
    qn_init = QN_NULL;
    qn_sname = name;
  }



let alloc_enum_cnst (scopes:qn_scope list) ((name, i):string * int):t =
  {
    qn_namespace = QN_DEFAULT;
    qn_span = QN_AUTO;
    qn_class = QN_ENUM_CNST i;
    qn_scopes = scopes;
    qn_init = QN_NULL;
    qn_sname = name;
  }
    


let alloc_param_name (scopes:qn_scope list) (name:string) (teid:int) :t =
  {
    qn_namespace = QN_DEFAULT;
    qn_span = QN_AUTO;
    qn_class = QN_PARAM_NAME teid;
    qn_scopes = scopes;
    qn_init = QN_NULL;
    qn_sname = name;
  }



let is_static t = 
  match t.qn_span with
    | QN_STATIC -> true
    | _ -> false

(*
let is_extern t = 
  match t.qn_span with
    | QN_EXTERN -> true
    | _ -> false
*)

let is_param t = 
  match t.qn_class with
    | QN_PARAM_NAME _ -> true
    | _ -> false
	

let is_var t = 
  match t.qn_class with
    | QN_DATA_ADDR -> true
    | _ -> false

let is_fun t = 
  match t.qn_class with
    | QN_CODE_ADDR -> true
    | _ -> false

let is_cstd_fun t = 
  match t.qn_namespace, t.qn_class with
    | QN_CSTD, QN_CODE_ADDR -> true
    | _ -> false

(* 
   the entity does not exist in original code, 
   it's generated by the compiler 
*)
let is_tmp t = 
  match t.qn_namespace with
    | QN_TMP -> true
    | _ -> false
    
let is_register t =
  match t.qn_class with
    | QN_DATA_REGI -> true
    | _ -> is_param t 

let is_global t = 
  let len = List.length t.qn_scopes
  in
  if len > 0 then
    let last = List.nth t.qn_scopes (len - 1)
    in match last with
      | QN_SCOPE_FILE str -> true
      | _ -> false
  else
    false
      
      
let is_enum t =
  match t.qn_class with
    | QN_ENUM_CNST _ -> true
    | _ -> false
	

let enum_const t = 
  match t.qn_class with
    | QN_ENUM_CNST v -> v
    | _ -> assert false


let equiv_param teid_eq t0 t1 = 
  match t0.qn_class, t1.qn_class with
    | QN_PARAM_NAME i0, QN_PARAM_NAME i1 ->
	t0.qn_sname = t1.qn_sname & teid_eq i0 i1
    | _ -> false


let map_param map t0 = 
  match t0.qn_class with
    | QN_PARAM_NAME i0 ->
	{
	  qn_namespace = t0.qn_namespace;
	  qn_span = t0.qn_span;
	  qn_class = QN_PARAM_NAME (map i0);
	  qn_scopes = t0.qn_scopes;
	  qn_init = t0.qn_init;
	  qn_sname = t0.qn_sname;
	}
    | _ -> t0



let param_teid qn = 
  match qn.qn_class with
    | QN_PARAM_NAME s -> s
    | _ -> assert false;
